# 开发最佳实践

## 代码规范

### 1. 命名规范

#### 文件命名
- 使用小写字母和连字符
- 保持文件名简洁明了
- 避免使用特殊字符

```
// 推荐
file-utils.js
search-service.js

// 避免
FileUtils.js
search_service.js
```

#### 变量和函数命名
- 使用驼峰命名法
- 函数名使用动词开头
- 常量使用大写字母和下划线

```javascript
// 推荐
const MAX_FILE_SIZE = 1024 * 1024; // 1MB
async function searchFiles(keyword) {}
const fileList = [];

// 避免
const maxFileSize = 1048576;
function SearchFiles(keyword) {}
const FileList = [];
```

### 2. 代码结构

#### 模块化组织
```javascript
// libs/file-utils.js
const fs = require('fs/promises');
const path = require('path');

class FileUtils {
    static async getFileInfo(filePath) {
        const stats = await fs.stat(filePath);
        return {
            name: path.basename(filePath),
            path: filePath,
            size: stats.size,
            mtime: stats.mtimeMs
        };
    }
    
    static formatSize(bytes) {
        // 格式化文件大小
    }
}

module.exports = FileUtils;
```

#### 单一职责原则
```javascript
// 推荐：每个函数只做一件事
async function searchFiles(keyword) {
    // 只负责搜索逻辑
}

async function filterFiles(files, criteria) {
    // 只负责过滤逻辑
}

// 避免：函数职责过多
async function searchAndFilterFiles(keyword, criteria) {
    // 同时处理搜索和过滤
}
```

## 性能优化

### 1. 异步操作

#### 避免同步阻塞
```javascript
// 推荐：使用异步操作
async function searchDirectory(dir, keyword, results) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    // 异步处理每个条目
}

// 避免：同步阻塞操作
function searchDirectorySync(dir, keyword, results) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    // 同步处理会导致 UI 卡顿
}
```

#### 合理使用 Promise
```javascript
// 推荐：使用 Promise.all 并行处理
async function processMultipleFiles(filePaths) {
    const promises = filePaths.map(filePath => 
        FileUtils.getFileInfo(filePath)
    );
    return Promise.all(promises);
}

// 避免：顺序处理
async function processFilesSequentially(filePaths) {
    const results = [];
    for (const filePath of filePaths) {
        const info = await FileUtils.getFileInfo(filePath);
        results.push(info);
    }
    return results;
}
```

### 2. 内存管理

#### 限制递归深度
```javascript
// 防止无限递归
async function searchDirectory(dir, keyword, results, depth = 0) {
    if (depth > 10) {
        console.warn('达到最大递归深度');
        return;
    }
    
    // 继续搜索逻辑
    await searchDirectory(subDir, keyword, results, depth + 1);
}
```

#### 流式处理大文件
```javascript
// 处理大文件时使用流
const readline = require('readline');
const fs = require('fs');

async function readLargeFile(filePath) {
    const fileStream = fs.createReadStream(filePath);
    const rl = readline.createInterface({
        input: fileStream,
        crlfDelay: Infinity
    });
    
    for await (const line of rl) {
        // 逐行处理
        processLine(line);
    }
}
```

## 错误处理

### 1. 统一错误格式
```javascript
class PluginError extends Error {
    constructor(type, message, originalError = null) {
        super(message);
        this.type = type;
        this.originalError = originalError;
        this.timestamp = new Date().toISOString();
    }
    
    toUserMessage() {
        const messages = {
            'FILE_NOT_FOUND': '文件不存在',
            'PERMISSION_DENIED': '无权限访问文件',
            'INVALID_PATH': '文件路径无效'
        };
        return messages[this.type] || '操作失败，请重试';
    }
}
```

### 2. 防御性编程
```javascript
// 参数验证
function validateFilePath(filePath) {
    if (typeof filePath !== 'string' || filePath.trim() === '') {
        throw new PluginError('INVALID_PATH', '文件路径不能为空');
    }
    
    if (!path.isAbsolute(filePath)) {
        throw new PluginError('INVALID_PATH', '文件路径必须是绝对路径');
    }
}

// 安全文件操作
async function safeFileOperation(filePath, operation) {
    try {
        validateFilePath(filePath);
        return await operation(filePath);
    } catch (error) {
        if (error instanceof PluginError) {
            throw error;
        }
        
        // 处理系统错误
        if (error.code === 'ENOENT') {
            throw new PluginError('FILE_NOT_FOUND', '文件不存在', error);
        } else if (error.code === 'EACCES') {
            throw new PluginError('PERMISSION_DENIED', '无权限访问', error);
        } else {
            throw new PluginError('UNKNOWN_ERROR', '未知错误', error);
        }
    }
}
```

## 用户体验优化

### 1. 响应式设计
```css
/* 适配不同窗口尺寸 */
.file-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
}

@media (max-width: 600px) {
    .file-list {
        grid-template-columns: 1fr;
    }
}
```

### 2. 加载状态反馈
```javascript
// 显示加载状态
async function searchWithFeedback(keyword) {
    showLoadingState();
    
    try {
        const files = await window.fileManagerApi.searchFiles(keyword);
        displayFiles(files);
    } catch (error) {
        showErrorMessage(error.toUserMessage());
    } finally {
        hideLoadingState();
    }
}
```

### 3. 键盘快捷键
```javascript
// 支持键盘操作
document.addEventListener('keydown', (event) => {
    if (event.ctrlKey && event.key === 'f') {
        event.preventDefault();
        focusSearchInput();
    }
    
    if (event.key === 'Escape') {
        clearSearch();
    }
});
```

## 安全性考虑

### 1. 输入验证
```javascript
// 防止路径遍历攻击
function sanitizePath(userInput) {
    const normalized = path.normalize(userInput);
    
    // 检查是否包含父目录引用
    if (normalized.includes('..')) {
        throw new PluginError('INVALID_PATH', '路径包含非法字符');
    }
    
    return normalized;
}
```

### 2. 权限控制
```javascript
// 限制文件访问范围
const ALLOWED_PATHS = [
    process.env.HOME,
    process.env.USERPROFILE
];

function isPathAllowed(filePath) {
    return ALLOWED_PATHS.some(allowedPath => 
        filePath.startsWith(allowedPath)
    );
}
```

## 测试策略

### 1. 单元测试
```javascript
// 测试工具函数
const { searchDirectory } = require('./search-utils');

describe('searchDirectory', () => {
    it('应该能够搜索到匹配的文件', async () => {
        const results = [];
        await searchDirectory('/test/path', 'keyword', results);
        expect(results.length).toBeGreaterThan(0);
    });
    
    it('应该跳过隐藏文件', async () => {
        // 测试隐藏文件处理逻辑
    });
});
```

### 2. 集成测试
```javascript
// 测试完整的搜索流程
describe('文件搜索功能', () => {
    it('应该能够完成完整的搜索流程', async () => {
        const keyword = 'test';
        const files = await window.fileManagerApi.searchFiles(keyword);
        
        // 验证搜索结果
        expect(Array.isArray(files)).toBe(true);
        
        // 验证文件信息结构
        files.forEach(file => {
            expect(file).toHaveProperty('name');
            expect(file).toHaveProperty('path');
            expect(file).toHaveProperty('size');
        });
    });
});
```

## 部署和维护

### 1. 版本管理
```json
{
  "version": "1.0.0",
  "changelog": {
    "1.0.0": "初始版本发布",
    "1.0.1": "修复文件搜索性能问题",
    "1.1.0": "新增文件预览功能"
  }
}
```

### 2. 错误监控
```javascript
// 错误上报机制
function reportError(error, context) {
    const errorReport = {
        pluginVersion: '1.0.0',
        timestamp: new Date().toISOString(),
        error: {
            message: error.message,
            stack: error.stack,
            type: error.type
        },
        context: context,
        userAgent: navigator.userAgent
    };
    
    // 发送错误报告（生产环境）
    if (process.env.NODE_ENV === 'production') {
        sendErrorReport(errorReport);
    }
}
```

### 3. 性能监控
```javascript
// 性能数据收集
function trackPerformance(operationName, duration) {
    const perfData = {
        operation: operationName,
        duration: duration,
        timestamp: Date.now()
    };
    
    // 记录性能数据
    performanceLog.push(perfData);
    
    // 如果性能异常，发出警告
    if (duration > 1000) {
        console.warn(`操作 ${operationName} 耗时过长: ${duration}ms`);
    }
}
```

## 快速文件管理插件特定实践

### 1. 搜索优化
```javascript
// 实现智能搜索
class SmartSearch {
    constructor() {
        this.searchCache = new Map();
        this.searchHistory = [];
    }
    
    async search(keyword, options = {}) {
        // 检查缓存
        const cacheKey = this.getCacheKey(keyword, options);
        if (this.searchCache.has(cacheKey)) {
            return this.searchCache.get(cacheKey);
        }
        
        // 执行搜索
        const results = await this.executeSearch(keyword, options);
        
        // 更新缓存和历史
        this.searchCache.set(cacheKey, results);
        this.updateSearchHistory(keyword);
        
        return results;
    }
}
```

### 2. 文件操作队列
```javascript
// 管理文件操作，防止冲突
class FileOperationQueue {
    constructor() {
        this.queue = [];
        this.processing = false;
    }
    
    async enqueue(operation) {
        return new Promise((resolve, reject) => {
            this.queue.push({ operation, resolve, reject });
            this.processQueue();
        });
    }
    
    async processQueue() {
        if (this.processing || this.queue.length === 0) return;
        
        this.processing = true;
        const { operation, resolve, reject } = this.queue.shift();
        
        try {
            const result = await operation();
            resolve(result);
        } catch (error) {
            reject(error);
        } finally {
            this.processing = false;
            this.processQueue();
        }
    }
}
```

## 总结

遵循这些最佳实践可以帮助您：

1. **提高代码质量** - 通过规范化和模块化
2. **优化性能** - 避免阻塞操作，合理使用资源
3. **增强稳定性** - 完善的错误处理和防御性编程
4. **改善用户体验** - 响应式设计和及时反馈
5. **确保安全性** - 输入验证和权限控制
6. **便于维护** - 清晰的文档和测试策略

在实际开发过程中，根据具体需求灵活应用这些实践，并不断优化和改进。

---

**返回**: [文档首页](../docs/README.md)